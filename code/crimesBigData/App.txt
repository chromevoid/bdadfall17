// PART I: GET CRIME RATE

// "community"
val crimes_raw = sc.textFile("path")

// ("comunity", count)
val crimes_count = crimes_raw.map((_, 1)).reduceByKey(_ + _)

// sum
val crimes_sum: Double = crimes_count.map(ln => ln._2.toInt).sum()

// "community,rate"
val crimes_rate = crimes_count.map(ln => ln._1 + "," + (ln._2 / crimes_sum).toDouble)


// PART II: GET GEO FEATURE

// "community,toCommunity,distance"
val distance = sc.textFile("/user/jy2234/project/distance")

val crimes_rate_key = crimes_rate.keyBy(_.split(",")(0))
val distance_key = distance.keyBy(_.split(",")(1))

// ("toComm",("comm,toComm,dis","toComm,rate"))
val join = distance_key.join(crimes_rate_key)

// "comm,geoSub"
val geoSub = join.map(ln => {
   val comm = ln._2._1.split(",")(0)
   val dis = ln._2._1.split(",")(2).toDouble
   val rate = ln._2._2.split(",")(1).toDouble
   val result = comm + "," + (dis * rate).toString
   result
})

// ("comm",["geoSub", ...])
val geo_groupby = geoSub.map(ln => (ln.split(",")(0), ln.split(",")(1))).groupByKey()

// "comm,geo"
val geo = geo_groupby.map(ln => {
  var result = ln._1
  val itStr = ln._2
  var sum: Double = 0.0
  for (each <- itStr) {
    sum = sum + each.toDouble
  }
  result = result + "," + sum.toString()
  result
})


// PART III: GET TAXI FEATURE

// "pickup,dropoff"
val taxi_raw = sc.textFile("path")

// "pickup,dropoff,count"
val taxi_count = raw.map((_, 1)).reduceByKey(_ + _).map(ln => ln._1 + "," + ln._2.toString())

// "pickup,dropoff,count"
val setzero = taxi_count.map(ln => {
  var result: String = ln.split(",")(2) + "," + ln.split(",")(3)
  if (ln.split(",")(2) == ln.split(",")(3)) {
    result = result + ",0"
  }
  else {
    result = result + "," + ln.split(",")(4)
  }
  result
}).sortBy(_.split(",")(1).toInt).sortBy(_.split(",")(0).toInt)

// ("dropoff,pickup",0)
val help = sc.textFile("/user/yz2444/project/taxihelp.txt").map(ln => (ln.split(",")(1)+","+ln.split(",")(0),ln.split(",")(2).toInt))

// ("dropoff,pickup",count)
val count_key = setzero.map(ln => (ln.split(",")(1)+","+ln.split(",")(0),ln.split(",")(2).toInt))

// (String, (Int, Option[Int]))
// ("dropoff,pickup",(0,count))
val count_join = help.leftOuterJoin(count_key)

// "dropoff,pickup,count"
val final_count = count_join.map(ln => {
  val keyStr = ln._1
  val option = ln._2._2
  var result = keyStr + ","
  if (option == None) {
    result = result + "0"
  }
  else {
    val count = option.toString().split("\\(")(1).split("\\)")(0).toInt
    result = result + count.toString()
  }
  result
})

// ("dropoff","pickup,count")
val tuple = final_count.map(ln => (ln.split(",")(0), ln.split(",")(1) + "," + ln.split(",")(2)))

// ("dropoff",["pickup,count", ...])
val groupby = tuple.groupByKey()
// "dropoff,sum"
val sum = groupby.map(ln => {
  var s: Double = 0.0
  val keyStr = ln._1
  val itStr = ln._2
  for (each <- itStr) {
    s = s + each.split(",")(1).toDouble
  }
  val result: String = keyStr + "," + s.toString()
  result
})

// ("dropoff","sum")
val sumGroupby = sum.map(ln => (ln.split(",")(0), ln.split(",")(1)))


// ("dropoff",("pickup,count","sum"))
val join = tuple.join(sumGroupby)
// "dropoff,pickup,subFeature" = "comm,toComm,weight"
val taxiWeight = join.map(ln => {
  val keyStr = ln._1
  val valueStr = ln._2
  val pickup = valueStr._1.split(",")(0)
  val count: Double = valueStr._1.split(",")(1).toDouble
  val sum: Double = valueStr._2.toDouble
  val feature: Double = count / sum
  val result = keyStr + "," + pickup + "," + feature.toString()
  result
})

val taxiWeight_key = taxiWeight.keyBy(_.split(",")(1))

// ("toComm",("comm,toComm,weight","toComm,rate"))
val taxi_join = taxiWeight_key.join(crimes_rate_key)

// "comm,taxiSub"
val taxiSub = taxi_join.map(ln => {
   val comm = ln._2._1.split(",")(0)
   val weight = ln._2._1.split(",")(2).toDouble
   val rate = ln._2._2.split(",")(1).toDouble
   val result = comm + "," + (weight * rate).toString
   result
})

// ("comm",["taxiSub", ...])
val taxi_groupby = taxiSub.map(ln => (ln.split(",")(0), ln.split(",")(1))).groupByKey()

// "comm,taxi"
val taxi = taxi_groupby.map(ln => {
  var result = ln._1
  val itStr = ln._2
  var sum: Double = 0.0
  for (each <- itStr) {
    sum = sum + each.toDouble
  }
  result = time + "," + result + "," + sum.toString()
  result
})


// PART IV: GET POI FEATURE

// "community"
val coffee_raw = sc.textFile("path")

// ("community","count")
val coffee_count = coffee_raw.raw.map((_, 1)).reduceByKey(_ + _)

// ("community",0)
val coffee_help = sc.textFile("/user/yz2444/project/taxihelp.txt").map(ln => (ln.split(",")(0),ln.split(",")(1).toInt))
vall coffee_count_key = coffee_count.map(ln => (ln.split(",")(0),ln.split(",")(1).toInt))

// (String, (Int, Option[Int]))
// ("community",(0,count))
val coffee_count_join = coffee_help.leftOuterJoin(coffee_count_key)

// "community,count"
val coffee_final_count = count_join.map(ln => {
  val keyStr = ln._1
  val option = ln._2._2
  var result = keyStr + ","
  if (option == None) {
    result = result + "0"
  }
  else {
    val count = option.toString().split("\\(")(1).split("\\)")(0).toInt
    result = result + count.toString()
  }
  result
})


// PART V: MODEL









